package router

import (
	"context"
	"fmt"
	"log"
	"net/http"
	"os"
	"time"

	"github.com/labstack/echo/v4"
	"github.com/labstack/echo/v4/middleware"
	"github.com/surahj/ai-mentor-backend/app/controllers"
	_ "github.com/surahj/ai-mentor-backend/docs" // docs is generated by Swag CLI, you have to import it.
	echoSwagger "github.com/swaggo/echo-swagger"
	"gorm.io/gorm"
)

// App the main interface to allow us inject global variables
type App struct {
	DB         *gorm.DB
	E          *echo.Echo
	Controller *controllers.Controller
}

// Initialize initializes the app with predefined configuration
func (a *App) Initialize(ctx context.Context, dbInstance *gorm.DB) {

	a.DB = dbInstance

	controller := controllers.Controller{
		DB: dbInstance,
	}

	a.Controller = &controller

	a.setRouters()
}

// setRouters sets the all required router
func (a *App) setRouters() {

	// init webserver
	a.E = echo.New()
	a.E.Static("/doc", "api")

	// rest compression middleware
	a.E.Use(middleware.Gzip())


	// add recovery middleware to make the system null safe
	a.E.Use(middleware.Recover())
	// sets up secure cookies middleware

	//setup CORS
	allowedMethods := []string{http.MethodGet, http.MethodHead, http.MethodPut, http.MethodPatch, http.MethodPost, http.MethodDelete}
	AllowOrigins := []string{"*"}

	corsConfig := middleware.CORSConfig{
		AllowOrigins: AllowOrigins, // in production limit this to only known hosts
		AllowHeaders: AllowOrigins,
		AllowMethods: allowedMethods,
	}

	a.E.Use(middleware.CORSWithConfig(corsConfig))

	// request timeout middleware
	a.E.Use(middleware.TimeoutWithConfig(middleware.TimeoutConfig{
		Skipper:      middleware.DefaultSkipper,
		ErrorMessage: "custom timeout error message returns to client",
		OnTimeoutRouteErrorHandler: func(err error, c echo.Context) {
			log.Printf("timeout on handler %s ", c.Path())
		},
		Timeout: 240 * time.Second,
	}))

	// logging miffleware
	a.E.Use(middleware.LoggerWithConfig(middleware.LoggerConfig{
		Format: "${method} | ${time_rfc3339} | status - ${status} | ttl - ${latency_human} | ${uri} | ip - ${remote_ip} \n",
		Output: log.Writer(),
	}))

	// auth routes
	a.E.POST("/signup", a.SignUp)
	a.E.POST("/login", a.Login)
	// a.E.POST("/verify", a.VerifyUser)
	// a.E.POST("/token/resend", a.ResendToken)

	// a.E.PATCH("/password/forgot", a.ForgotPassword)
	// a.E.PATCH("/password/reset", a.ResetPassword)

	a.E.GET("/status", a.GetStatus)
	a.E.GET("/docs/*", echoSwagger.WrapHandler)

	//status
	a.E.POST("/", a.GetStatus)
	a.E.GET("/", a.GetStatus)

	a.E.GET("/docs/*", echoSwagger.WrapHandler)
}

func (a *App) GetStatus(c echo.Context) error {
	return c.JSON(200, map[string]string{
		"status": "ok",
	})
}

// Run the app on it's router
func (a *App) Run() {

	host := os.Getenv("SYSTEM_HOST")
	if host == "" {
		host = "0.0.0.0"
	}

	port := os.Getenv("PORT")

	if port == "" {
		port = os.Getenv("SYSTEM_PORT")
		if port == "" {
			port = "80"
		}
	}

	server := fmt.Sprintf("%s:%s", host, port)

	log.Printf(" listening on %s ", server)

	a.E.HideBanner = true

	a.E.Logger.Fatal(a.E.Start(server))
}
